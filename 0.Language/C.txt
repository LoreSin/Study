
C언어 특징
	- 절차지향
	- 높은 이식성 (CPU 단위). But 처음 나올 당시 기준이며, 현재는 더 나은 언어있음.
	- 성능 우위. 가장 Low 에 가까운 High Level Language
IDE 
	- IDE = Integrety Develop Environment
	- 윈도우에서는 visual studio IDE 를 사용. (community 버젼)
	- OS 별로 추천되는 IDE 가 다양함. (Eclipse, IntelliJ, Xcode, Clion 등)
	- Project 단위로 프로그램을 작성.
	- 프로젝트 여러개의 그룹 => 솔루션으로 정의되며, 여러개의 프로젝트를 포함 가능.
	- 실습중에는 솔루션 당 프로젝트 1개로 유지.
	- 파일의 추가는 탐색기에서 추가하여 코드 및 리소스를 추가 


프로그램 작성
	- main 함수는 하나의 프로젝트에서 하나만 존재 해야함. 프로그램의 시작함수로 정의되는 것.
	- 여러개의 파일에서 main 함수를 사용한 경우, 파일을 솔루션탐색기에서 일시적으로 [제거] 하고, 빌드. 파일은 삭제하지 않고, 교체하여 빌드 할수 있음.

자주쓰는 함수
	- main : 프로그램을 시작하는 함수명 정의
	- printf : 문자열 출력하는 함수 (문자, 숫자 등) format 을 포함한다. (%d, %f, %c 등으로 숫자 또는 문자까지)
	- scanf : 문자입력을 받는 함수 (문자, 숫자 등) format 을 포함한다. (%d, %f, %c 등으로 숫자 또는 문자까지)



주석
	- 소스코드의 메모
	- // 로 단행 주석 가능. 
	- /* ~~~
	~~~~~ */ 으로 다행 주석 가능.
	- 오래된 프로그램을 다시 볼때 필요함. (자신)
	- 협업을 위해서 작성해야 하는 경우가 있음. (타인)

	- 일시적인 디버그를 위하여 주석을 사용할때는 // 을 위주로 사용. 다행주석은 실수를 만들기 쉽다.

	ps. 주석이 없는 코드가 낫다 by pep (python)


변수
	- 변수 : 메모리공간에 데이터를 저장하는 크기단위.(integer, char, double...)
	- 선언법 [type name] ex. [int num1;]
	- 선언초기화 [type name = X] ex. [int num1 = 5;]
	- 변수 다중선언. [int A, B, C;]
	- 변수이름 규칙
		영어 + 숫자 + _ (언더바) 로 구성.
		영문는 대소문자 구분
		숫자시작, 키워드(프로그래밍에 사용되는 단어), 공백 사용 금지
		_ 언더바시작은 특정한 예약으로 시작할때 쓰이기도 하므로, 기피.


연산자
	+, -, *, /, % 등의 4칙연산
	+=, -=, *=, /=, %= 등의 대입연산  (계산후 앞의 변수에 값을 대입)
	++, -- 증가/감소 연산자 (해당 라인의 코드 실행전 또는 후에 1의 가감산을 수행) 
	<, >, ==, !=, <=, >= 등의 비교연산 (큰가, 작은가, 같은가, 다른가 등)
	&&(and) || (or) ! (not) 등의 논리연산


사용자 입력
	scanf("%d", &num);
	- & 을 붙여서 사용하여 변수에 저장가능. (변수 변경을 허용하는 구문으로 이해하자.)
	- %d 는 입력된 데이터의 유형을 지정. (%d = 숫자, %c = 단일 문자등)


데이터(자료) 표현단위
	- bit = 2진수 1자리 데이터 (0,1)
	- 16진수는 0~9 + A, B, C, D, E (10진수의 10~15) 로 한자리에서 표현. 
	- 2진수 => 8진수는 3bit 로 데이터를 표현 (2진수 111 => 8진수 7)
	- 2진수 => 16진수는 4bit 로 데이터를 표현 (2진수 1111 => 16진수 E)

	- 2진수 bit의 묶음 (8비트, 16비트) 로 표현. (OS 의 데이터처리단위 구분이기도 함)
	- 8bit = 1byte, 4byte = 32 bit

	- 012 등으로 0으로 시작하는 숫자는 8진수로 인식.
	- 0xA 등으로 0x 로 시작하는 숫자는 16진수로 인식 


기본 자료형 
	- 데이터 표현하는 방법 & 크기가 정해진것
	- 변수(변경 가능한 값) & 상수 (고정된 값)
	- 정수형 - 실수형 / 데이터 크기별로 구분된다.
	- 정수형 : char(1Byte) - short(2Byte) - int(4Byte) - long - long long
		주로 int 사용
	- 실수형 : float(4Byte) - double(8Byte) - long double
		주로 double 사용
	- unsigned + XX : MSB (부호비트) 까지 숫자의 크기로 사용됨.

	- 아스키코드 (ascii) : 숫자를 가지고 문자를 출력(표현) 하기 위한 기준 
		65~90 - A~Z 등으로 출력
		출력양식은 %c (단일문자) , %s (문자열) 등을 사용

	- 통상적으로 Int = CPU 연산의 기본단위 (16bit CPU / 32bit CPU 등)
	- 정수는 int, 실수는 double 을 기본적으로 사용함.


상수 : 메모리상에서 값이 변하지 않는 값
	const 를 변수명 앞에 붙인다. (사용은 변수처럼, 수정은 불가능)

형변환
	- 자동 형변환: 값이 대입될때 or 계산식의 형이 같지 않을때
		double + int => double + int
		작은 바이트에서 큰 바이트로, 형 변환은 정수 => 실수로 우선.
		int => long => long long => float => double => long double

	- 강제 형변환: 계산값이 제대로 처리 되지 않을때 or 특정한 데이터로 변화 시킬때 
		result = (double) A / B  : 명시적 형변환
		형 변환이 일어나는 자리에는 별도로 명시 하는것이 좋다. 
		result = 2.5 * B >>> result = 2.5 * (double) B


반복문 while
	while (조건식) {
		실행문
		필요시 조건해제문 추가
	}

	조건식이 "참" 일때 (수학적으로 0 초과) 실행문을 반복적으로 수행.
	들여쓰기 하는게 좋고, 중괄호 넣는것도 좋다.

	무한루프 => while 조건식에 1을 직접 넣거나, 조건 해제가 없는경우 발생
	cmd 에서는 ctrl+C 로 탈출

	중첩하여 사용하면, N*M 회의 내용이 2중 while 구문이 실행된다. (ex 구구단 전체출력)

반복문 do~while
	do{
		실행문
	}while(조건식);

	실행문을 한번 실행한 후에 조건식을 검사한뒤 복사.
	거의 while 문과 유사하나, [최소 1회] 는 반복한다.


반복문 for
	for (초기식; 조건식; 증감식){
		실행문
	}

	초기식에서 변수 선언후, 조건식을 거치고 실행문-증감식 순으로 실행. 
	다시 조건식 - 실행문 - 증감식을 반복하고, 조건식이 false 일때까지 반복
	초기식에서 선언되는 변수는 같은 스코프에서 쓰이기 때문에 주의.


분기문 : 조건이나 상황에 따른 선택적 실행을 유도.
	if(조건식){
		실행문
	}
	
	if조건문이 올바르면 실행문을 수행. 아니면 넘어감.

	if(조건식){
		실행문1
	}
	else{
		실행문2
	}

	if~else~ 구문은, 조건이 올바르면 실행문1, 아니면 실행문2를 실행한다.
	조건식의 여부에 따라 둘중 하나를 실행.


	break & continue
	특정 반복문을 탈출 or 회귀 하는 코드.
	for(~~){
		break; or continue;
	}

	switch(식)
	{
	case 1:
		실행문
		break;
	case 2:
		실행문
		break;
	case 3:
		실행문
		break;
	default:
		실행문
		break;
	}

	break 를 빠트리면, 아래쪽 구문이 모두 실행됨. break 는 구분자로 쓰임.



함수
	main 함수 : 프로그램이 가장 먼저 실행되는 함수. (시작함수)
	반환형 함수명(인수형 인수명){
		실행문
	}

	반환형은 데이터형 // 함수명은 호출할때 쓰일 이름
	인수형 & 인수명은 함수호출때 외부에서 받아오는 데이터형 & 변수명

	반환형 함수명(인수형 인수명);
	main 함수~~~
	반환형 함수명(인수형 인수명){
		실행문
	}

	과 같은식으로, 선정의-후구현을 해도 된다. 컴파일러 특징상, 선언이 먼저 필요하지만, 구현이 나중에라도 되면 OK.



지역변수 (로컬변수, Local Variable)
	중괄호 {} 안에서[만] 사용할수 있는 변수
	{} 는 프로그래밍상 변수가 살아가는 지역을 의미
	다른 지역에는 동일한 변수명을 사용할수 있다. (같은 지역 불가능)
	해당 지역의 실행이 끝날때, 변수가 없어진다.

전역변수
	메인함수 바깥, 함수선언과 같은 지역에서 정의된 변수
	모든 영역에서 접근 가능함.
	다른 {} 에서 같은 이름의 변수를 지어도 가능하지만, 해당 전역변수를 접근할수 없다.
	안 쓰는게 좋다.

정적변수 (static variable)
	특정 지역(함수등) 에서 선언하여 사용
	static int num;

	변수의 취급은 전역변수. 프로그램이 종료될때 까지 메모리상에 유지
	변수의 접근은 지역변수. 특정 함수에서만 접근&조작 가능
	전역변수를 쓰는것이 아니라, 정적변수를 사용하여 안정성을 높임.

재귀함수 (Recursive)
	자기자신을 다시 호출하는 함수의 형태
	void recursive(int n){
		if !n
			return
		else
			return recursive(n - 1);
	}

	반드시 종료되는 조건 (ex if 문) 이 필요함.
	주로 수학공식 이나 알고리즘구현에 많이 사용됨.

배열
	int A[10] = {1,2,3 ...}
	char[] str = "qwe"
	등으로 선언
	A[1], str[0] ... 변수명[순번] == name[idx]
	등의 방법으로 접근하며, 해당 idx 자리에 변수명을 넣어서, 접근 가능하다. (실제로 사용한 범위가 넘어가면 이상한 값이 나올수도 있다)

	str은 특수하게 처리되며, scanf 등을 사용할때 & 을 넣지 않아도 된다.
	str 의 끝은 아스키코드 0 = '\0' 으로 끝난다.

포인터
	int a = 10;
	int* A = a;
	형명에 애스터리스크(*) 을 붙이고 선언하면, 해당 변수는 해당 형의 포인터로 선언된다.

	포인터는 타 변수를 가르키는 용도로 주로 쓰이며, 직접 제어도 가능
	포인터의 메모리는 기본적으로 4Byte 의 크기를 가짐 (32bi)t
	포인터 선언시에 정해진 "형에 따라 메모리의 접근영역크기와 단위" 가 정해진다.

	char b = 'Q';
	char* B = b;
	unit* name = reference;

	B 포인터는, 메모리상으로는 4Byte 를 가지지만 메모리를 접근하여, char 의 메모리크기 (1Byte) 만큼 조정한다.

	*B += 10; // B(가 지시하는) 값에 접근하여 연산
	B = &b; // ptr1(가 지시하는) 주소를 num2 의 주소로 지정
	B = B + 1; // B(가 지시하는) 주소에 B의 +1 위치의 주소를 지정.

	포인터는 값을 직접 가지고 있는것이 아니라, 값을 가지는 다른 변수(또는 주소) 를 가리킨다는 뜻이다. 

포인터와 배열
	int arr[5] = {1,2,3,4,5};
	int* p = arr;

	printf("%d \n", *p);
		p가 가리키는 위치 = arr = &arr[0] = 1
	printf("%d \n", *(p+1)) == printf("%d \n", p[1]))
		p의 주소+1(unit) 값이 가리키는 위치 = arr = &arr[0] = 1



포인터와 문자열
	char str[] = "Hello World"
	char* ptr = str; // ... 1)
	ptr 는 str의 첫 글자를 가르키는 포인터로써, 기능하며, str 은 원래 저장된 글자열 위치에서 포인터 같은 기능을 한다.
	*(ptr+1) == *(str+1)
	그리고 str 변수명은 포인터처럼 사용될수 있지만, 다른 변수를 가리킬수는 없다. 가리키는 위치가 고정된 포인터라고 생각하면 된다

	char* ptr = "hello"; // ... 2)
	문자형 포인터에 문자열을 저장하면, 해당 문자열 "상수화" 되어서, 변수나 포인터가 아닌, "상수영역 메모리" 에 상수로 할당된다.
	이 문자열은 다시쓰기 (*ptr = 4) 가 불가능하고, 오직 읽기(read only)만 가능.

	C언어의 char배열
	일반적으로는 1) 과 같이 변수형 문자열의 특정한 위치에서 문자열을 취급하는 용도.
	2) 의 경우 RO메모리 (상수영역메모리) 에 저장되어, 재사용성을 위해 저장됨.
	실제 2) 의 경우 저장되는 메모리영역도 달라짐.

	리터럴은 변수에 저장할수 있는 유형의 값을 뜻함.

const 상수
	const int NUMBER = 111233124552;
	값을 변경할수 없는 수 (상수) 를 선언할때 사용. 
	프로그램 내에서 "절대로 바꾸지 말아야 하는 숫자" 를 사용할때.
	형명은 대문자 사용 권장.
	메모리상 위치는 일반적인 변수와 같이 저장됨.

포인터배열
	char* 은 스트링(문자열) 을 저장할수 있는 문자배열이다.
	
함수와 포인터
	void func(int* arg)
	함수가 포인터를 받거나, 포인터로 하여, 참조값(주소) 를 가져온다
	배열변수를 하나 입력받아도 배열요소를 모두 출력하거나, 접근 가능

	만약 포인터를 받는 함수에 int 등의 자료형이 정의된 변수를 입력시키면, 해당 변수의 "주소값" 이 넘어가고, 대체로 에러가 발생한다.

	함수의 인자가 포인터로 된 경우, 주소값을 넘기는 식으로 쓴다.
	void func(int* arg);
	int a[3] = {1,2,3};
	int b = 5;
	func1(a);
	func1(&b);

	함수의 인자가 다른 형명일 경우, 값을 넘겨주는 방식으로 쓴다.
	void func(int arg);
	int a[3] = {1,2,3};
	int b = 5;
	func1(*a);
	func1(b);


2차원 배열
	int popy[4][3];
	int arrrray[2][2] ={
		{1,2},
		{3,4}
	}
	배열이 2번 겹쳐진 형태를 말함. 선언과 동시에 정의 가능.
	접근시 name[3][2] 와 같은 idx 를 두번 써야함.


3차원 배열 
	int popy[4][3][3];
	그냥 배열에 배열에 배열을 더 붙인거 


point of point (포인트의 포인트)
	int a = 5;
	int* b = &a;
	int** c = &b;

	c 는 b 를 가리키고, b 는 a를 가리킨다.
	c 는 * 를 두개를 사용하여, 포인터의 기능을 2번 까지 사용하여, 참조의참조가 가능. 

	printf("%d", **c);
	를 출력하면, a의 값인 5가 출력된다.

	c => b => a 순으로 2번의 참조를 하게 된다. (즉, *의 갯수 만큼 참조 가능)


배열 포인터 vs 포인터 배열
	int arr2d[2][4] ={...};	//2차 배열
	int * whoA[4] ={...};	//포인터 배열
	int (*whoB)[4] = arr2d;	//배열 포인터
	whoA 는 기존의 배열에 int포인터를 담을수 있다.
	whoB 는 *whoB 라는 포인터형식의 변수가, int[4] 의 배열을 


함수포인터 void포인터
	함수를 가리키는 포인터를 말함
	int add (int a, int b);
	int(*e)(int, int) = add;
		선언할때 입출력 형식을 지정하여, 어떤 형태의 함수를 사용할지를 지정.
		입출력 형식이 같은 함수를 지정하여, 호출가능
		형식이 같다면, 다른 함수를 재정의 하여, 사용하는것도 가능.

	void* etc;
		아무거나 넣을수 있는 포인터
		어떤건지도 모르는 대상의 주소를 담아두는 용도
		void 이기 때문에, 자료형으로 출력할수는 없다.


Computer의 장치 처리구조
	1. CPU (연산과 제어장치)
	2. FILE (장치간 데이터 전달단위)
	3. I/O Device (데이터를 입력 받거나, 보내는 장치)
	FILE 형태의 데이터가 CPU 처리 이후 출력으로 보내는 형태 => 스트림


스트림을 이용하는 입출력방법
	ch1 = fgetc(stdin); 글자를 하나 입력받는다. 
	fgets(ch1, N,stdin) ch1 에 N 개의 문자를 stdin 에서 입력받는다.
	fgetc, fgets (출력)	fputc, fputs(입력)

버퍼 (Buffer)
	장치간 속도차이로 인한 메모리 입출력버퍼용 공간
	버퍼를 이용해, 느린곳에서는 해당 기기에 맞는 속도로 읽거나 쓴다.


fflush (버퍼즉시전송)
	버퍼의 내용으로 인해 출력이나 입력이 이상해지는 경우 사용. 스트림 속도차이로 인해 생기는 문제 방지.


문자열 처리 함수
	strlen : 문자열길이
	strcpy, strncpy : 복사
	strcat, strncat : 붙이기
	strcmp, strncmp : 문자열 앞에서 비교.


구조체 - Struct
	데이터를 효율적으로 관리하기 위한 관점의 최소단위.
	선언
		struct 구조체명{
			변수형 변수명
			...
		}

	사용
		struct 구조체명 변수명 = {VarData}
		struct 구조체명 변수명[n] = {VarData...}

	typedef struct 구조체명 대체형명
		타입이름을 추가로 지정

열거형 - Enum
	struct 처럼 변수를 정의하나, 상수 처럼 특정한 숫자를 지님.

	typedef struct(enum 가능) 창고명{
		~~~
	} 대체명;
	typedef struct(enum 가능) 창고명 대체명{
		~~~
	};

 	등으로 생성시에 추가적인 대체명 추가 가능.


FILE 과 fopen
	FILE* file = fopen("파일명", "파일모드")
	fwrite(~~)
	fread(~~)
	fgets, fgetc, fputs, fputc 등으로 파일접근 및 쓰기가능


malloc, free : 메모리 동적 할당 및 해제
	int* num1 = malloc(N) <= N Byte 만큼 메모리 할당.
	int* num1 = malloc(sizeof(int) * n) 등으로 사용.
	int* num1 = calloc(sizeof(int), n) 등으로 사용. 0으로 초기화됨.
	int* num1 = realloc(sizeof(int)) 등으로 메모리 재할당

	사용이 끝나는 경우, free 를 하여, 메모리를 상환하는 것이 메모리관리가 된다.
~
preprocess 선행처리기, macro 매크로

	#define PI 3.14
	프로그램이 만들어지기전에 코드의 해당 부분을 치환
	예전에는 상수 or 성능으로 인해서 많이 사용됨.

	#if 조건문
		~~실행문
	#endif
	컴파일러에서 해당 실행문을 실행할지 말지 결정하는방법?



